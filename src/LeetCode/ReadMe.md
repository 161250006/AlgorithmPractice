#LeetCode做题记录与经验

##1.DP
找到最优解法常常使用DP，如最大/最小/最多/最少等。

DP步骤--1.定义DP数组的含义；2.找出数组元素间的关系；3.找出初始值。其中最重要的是1，需要找出
合适的DP数组，并且需要划分出元素的状态，再在2中找到不同状态的转移公式。

80%的字符串题目使用DP，且大多数使用二维数组，如最长回文字符串（5）

如字符串匹配问题：正则表达式匹配（10）：构建以两个字符串构建二维dp数组，值为是否匹配，其中空字符串记录为0，所以要往后加一位

01背包问题--一个背包内能装的最大价值的物品，分割等和子集：能否分出总和的一半（416）

使用两个数组--找山脉（845），分别用left和right数组找到两翼，焦点即为山顶

其他特殊问题--秋叶集（LCP19）、dfs+dp思想（968）、视频拼接（1024）

优化及将二维数组转化为一维，适用于适用上一行的数据的题目，注意优化时可能需要使用倒序，避免覆盖上一层数据。

dp有可能是并不是从之前的某一两个状态得到当前状态，可能是之前的所有状态循环判断（139）

***股票购买问题：No123（我自己写出来的困难！！！），最多完成两笔交易，通过构建不同状态作为dp数组的第二位做状态之间的推导。
No713,加手续费的股票购买，构建二维数组，分为持有和未持有两个状态，进行状态转移。No188,最多完成k次交易，是对两次的扩充，第二维度变为k，然后找分奇偶数推导即可（我又做出来了）。

乘积最大值问题（152）：类似的题目可以构造以某一点为结尾的dp数组，这样就不用了关心不连续问题，然后最终结果是所有值的最大值。
此题注意考虑负数的情况，需要分别构造最大值数组和最小值数组，最后的最大值是分别和最大值最小值相乘的最大值。

简单的dp(746上楼梯,509斐波那契数列)
##2.DFS
回溯递归，记得记录已经搜索的节点，并在一次回溯结束时设置为初始值

回溯的优化--剪枝，最好画图，看清楚剪的是循环中的（广度）还是递归体中的（深度）。

注意排列是每次从头开始，组合是每次从后一个开始

字符串/数组的排列组合（17,39、40、47，60，77，78），一些特定的游戏（数独37，N皇后51/52，单词搜索79）

图论有关（547省份问题，399）：可以用并查集优化
##3.二叉树
前中后序遍历，迭代实现，其中前序的迭代实现是用栈，循环判断栈是否为空，先加入右子节点，再加入左子节点；
后序先使用中右左的顺序，即循环内先左再右，然后翻转链表，与前序相似；
中序和前后序不同，要加入一个指针，用指针搜索树，使用栈用于保留中间节点，判断条件是两者非空。

二叉树的构造--找中间节点——前序和后序的中间节点分别是第一个和最后一个，
然后根据这个去找中序数组中的中间节点得到两棵子树的长度，再回到前序或者后序的数组内得到两棵子树，并开始递归。

二叉查找树的搜索，注意二叉查找树的性质--中序搜索是排序，大多数的二叉搜索树的题目使用中序遍历

中序优化为O(1)--Morris 中序遍历(不会)

二叉树迭代搜索（94，144,145），构造二叉树（106）、二叉树dfs（113、（翻转二叉树）226、257，404，617，968???,129），
二叉搜索树（235、501、538、701）

##4.BFS
用队列实现，如需分层，则每一次循环后再加一个循环出队列。

二叉树层次遍历（103、107、116、117、637），单个层次中间只需要得到队列的大小，即可完成遍历，而不需要重新创建一个新的数据结构。

图的搜索（127.得到从一个单词到另一个单词的最短序列），可以使用双向
bfs以缩小范围减少时间复杂度，构建图的时候可以不用全部遍历，通过构建中间虚拟节点进行构建，
以减小时间复杂度。使用广度优先搜索的原因：遍历的层数越少说明路径越短。所以取第一个访问到终止节点的。

距离顺序排列矩阵单元格(1030):可以用bfs搜索数组
##5.双指针/多指针/链表问题
链表综合问题--143重排链表（使用快慢指针找到链表中点，翻转链表，最后双指针完成归并），763（类似143，注意找中点的快慢指针的终止条件是next=null或next.next=null）

链表问题使用多指针较多--删除倒数第n个节点（19）

链表环问题--快慢指针，环入口在快慢指针相遇时再加一个指针，再次与慢指针相遇处（141、142）。

*归并问题--双指针（2、3、977、844（字符串退格问题，双指针逆序遍历），349）。

滑动窗口--无重复字符串的最长子串（3），划分字母区间（763）,找山脉（845）。

改变链表顺序--三指针，前中后。
翻转链表，两两交换链表中的节点（24）

57,模拟插入区间，双指针确认需要归并的区间大小，每次判断是否需要归并区间，不断改变需要归并的区间大小。

奇偶数：交换奇偶数（922），构造奇偶数链表（328，先构造两个链表再连接）

交换数字：移动零（283）

**盛水最多的容器（11）：经典算法，两个指针在两端向中间移动，每次移动较小的那个，这个过程中的最大值就是答案，证明见题解

**两数之和1/三数之和15/四数之和18：经典算法，证明思路和上面的差不多，重点是决定好三/四个数的大小，a<b<c则不会重复；做法是先排序，然后第一个数作为第一层n的循环，后两个数计算合为结果-第一个数的组合，用双指针计算（一头一尾，往中间走直到重合,小了就左边走，大了就右边走），细节在算法中。
四数的则是比三数字的多一层循环，其他一样。
三数之和---16，与之前的思路相同，这里注意left是从i+1开始的，也就是遵循a<b<c的原则，避免重复。

分割链表（86）--构造左右两个链表然后合并即可，***记得右边的链表的最后的next要设置为null，不然会出现环。

简单双指针(228)
##6.哈希表
将数组下标置于值部分，用于从值得到下标，如两数之和（1）

不一定适用hashmap，如查找常用字符（1002），对于字符串题目，可以使用26个英文字母组成的数组,(242),有unicode要使用hashmap，可以还是用char。

计数排序--使用哈希的思想，一种特殊的桶排序，列出数组中值的范围创建新数组，然后
记录每一个数字出现的次数，最后直接排序（1365，1122）。

普通（1207，389，387）

当出现O(1)复杂度的添加删除操作的时候，可以考虑hash表（hashset/hashmap等）（381）,
小技巧：将list转为set减少时间复杂度，还可以直接使用contains方法

四数相加(454)：回溯/循环复杂度太高，用hashmap存储结果，分开计算

同构字符串(205)：双映射问题，构造两个hash表互相映射，都满足才可以（一对一关系）。
##7.优先队列（堆）
每次入堆，手动控制堆大小

第K大（小）问题（347,973）

767重构字符串：使用大根堆排序，每次取出两个，可以即避免相邻字符相同，又优先加入出现频率高的字符。

普通（1046）

滑动窗口最大值（239）：这题告诉我们不能remove，要记录每个数字的位置，然后判断一个个poll，否则会超时（remove是On复杂度）。
这题还可以用双端单调栈解决，创建一个双向单调队列，里面记录的是数字的下标，按从大到小排列，每次在右边加入新元素后，按单调栈移除老元素，然后在左边移除老元素后得到最大值。
##8.二分查找/分治
涉及log(n)复杂度的查找，特别是排好序的数组，如（4，74）。

while(left<=right)

34范围搜索//直接二分搜索，查找第一个大于等于target的树，和第一个大于target的数，并且代码复用

*为数不多的必须使用二分查找的问题，对于范围的二分查找（1-5,1-10），桶容量问题（找到分割数组中的和的最小值）,将数组中的最小值最为左值，数组的和作为右值，进行二分搜索，每次判断中值是否能够满足题目所需的桶数目，直到小于则变小，大于则变大，直到左值和右值相等。
##9.贪心
每次选择局部最优解，记得排序，贪心第一想到的就是能否对数组进行排序，包括区间的排序（对开始或者结束进行排序）。

***区间调度问题--视频拼接（1024），记录每个起始节点单个区间能到达的最大节点，然后遍历
数组，得到每次最大的区间，每过一个区间就+1。
记住这个算法：排序后贪心（452，气球射击问题）：先对气球区间的第二位进行排序，然后以气球第二位每个气球
第二位为射击点，查看最小射击数，由于新的射击点必然大于老的设计点，所以可以不用list储存而是用一个值储存，同样可以判断是否设计击穿。
股票问题：122，每次累加比昨天多的部分。
无重叠区间（435）:和气球设计的相似，都是一样的算法，要记住，就是用总数减去最小射击（最多不重叠的个数），得到的就是最小的减去区间的个数。

贪心+单调栈（402）：移掉k个数字使得剩下数字最大，用栈储存已经访问过的数字，
然后每到一个数字对移除栈顶元素直到比栈顶比那个数字小。单调栈：存放的顺序单调递增或递减的栈

排序后插入（406，身高排序问题）：先对数组排序，其中相同身高的人按前面有多少个人排序，且排序方式与身高排序相反，
然后逐个插入，递增排序则为后面插入的人留位置，递减排序则数前面有几个人插入。

排序后贪心（976）三角形周长问题。(455分发糖果)：先对孩子和糖果数组排序，然后从大到小找到适合孩子的糖果，适合的+，不适合的跳过。
136分发糖果（非排序，只是分发糖果）---分别通过左右两次贪心，最后合并得到最终结果（两次结果中的更大的值）。

*767重构字符串，计数排序，按奇偶数插入，先奇数后偶数，因为只有奇数长度字符串时且里面数量最大字符的数量是（n+1）/2时需要从偶数开始排，其他直接从奇数即可。

659分割数组为连续子序列：使用大顶堆存储子序列长度，每次向前一个子序列中最小长度的添加新节点，最后得到的就是每条子序列长度最大的结果。

621模拟CPU执行任务：没仔细看，可以再看看

738单调递增的数字：找到后一个比前一个小的数字，然后逐个借位借回去，直到满足借位后仍然递增，然后填9即可

316/1081---去除重复字母，用栈的思想（可以用栈也可以手动模拟栈），一个个加，而不是删，遇到前一个大于后一个的就一个个往前删，直到前一个小于后一个，注意设置访问数组，可以防止重复添加

330按要求补齐数组---通过数学证明，得到对于正整数x，如果区间 [1,x-1]内的所有数字都已经被覆盖，且x在数组中，则区间[1,2x-1]内的所有数字也都被覆盖。
所以x从1开始（这里的x就是[1,x]中的x，就是已经覆盖的最大值），每次查看数组中的元素，如果数组中元素小于x，则说明已经覆盖，可以让x加上，如果大于x则说明没有覆盖，让x*2直到大于这个数，循环直到x大于n。

简单贪心（605）
##10.排序
桶排序（1030）：将整个数组分为几个范围不同的桶，然后将数字一个个放入，桶的粒度可以自己控制（一般是（最大-最小）/长度，方便放入时候通过计算直接找到放入的桶）。对于桶内不需要具体排序或排序比较简单的可以用桶排序降低时间复杂度，1370对于26个英文字母也可以采用桶计数的方法，（164）

基数排序：一种特殊的桶排序，从个位数开始，将每个数字分别放入桶中，然后每次按顺序重新放入桶中，退后完成排序。

计数排序--使用哈希的思想，一种特殊的桶排序，列出数组中值的范围创建新数组，然后
记录每一个数字出现的次数，最后直接排序（1365，1122）。

归并排序--148，自顶向下归并排序用递归，拆分后合并；自底向上归并排序，用多层循环模拟（比较复杂，空间复杂度可降为o（1））.
*（493，327（困难））找到指定前序，减小时间复杂度。方法使用二分，最终递归的返回值是两个数组中的翻转对+一边一个的翻转对；然后找到一边一个的翻转对后归并两个数组再递归；其中由于是递归归并的，所以这两个都是有序的，所以找一边一个的复杂度是o（n）。
（1-21找到倒置数字对的个数），归并排序过程中查找，右边小于左边的即是，加上mid-i+1（当前左边元素和中间元素中的间隔，因为都大于右边元素）即可。

插入排序--147，每次向排序好了的链表中插入新的节点，1-16如果不用链表的话就在第二层循环中从后向前判断，对于大于的数就往后移动一位，知道符合条件的位置插入即可,记得插入排序是从1开始的（希尔是gap），记得在移动法时使用temp，代替插入的元素，不然原本位置的会被冲掉，而且j要在外面赋值，在循环外完成插入，不然可能无法插入。（所以还是交换法更好）

希尔排序（1-22）--插入排序的变种，用增量分组，第一次是len/2，而后每次/2，然后对于分出的组进行插入排序，最后直到增量为1，排序完成https://www.cnblogs.com/han200113/p/11722999.html

冒泡排序（1-17）--两重循环都从0开始，第二重以len-i-1结束，每次比较j和j+1，j<j+1就交换

快速排序（1-19）--常用递归方式，每次取第一个点最为基准点，然后左右双指针（先右后左）分别循环得到不满足的值，然后交换，直到指针重合，循环结束和将第一个值和重合值交换（这里有一个小的数学证明），然后递归即可。具体看代码。
非递归方式用栈实现，就是用栈模拟递归的顺序，有点像二叉树的栈的遍历，每次将左右节点入栈，出栈左右节点，然后调用partition方法（和递归的一样）得到中心点，然后再次分别入栈，直到栈空为止，和递归的差不多。

##11.图论
并查集：除法求值（399）--最简单容易想到的就是先构造加权图然后dfs/bfs，记得构造图的过程中用map存储点，用list存储边（需要自定义边），然后进行bfs查找结果。
然后是并查集，并查集的使用见下面的说明。547计算省份，1202字符串排序,684冗余连接，之后冗余连接的题可以尝试用并查集写。
947（移石头），合并邮箱（721）：这一题有点烦，题意不清晰，注意去重，要把每个邮箱当成一个节点，而不是账户作为节点，用两个hashmap储存，自动去重。
1584（最小生成树）：Kruskal算法，用并查集检查选中的边是否成环，算法的说明在下方。
1489题没看懂，做个屁。1319网络连接，比较普通。959划分区域，比较难。
1579,图的连接，分情况讨论。注意并查集的中可以在unit方法中添加如果两个节点已经是同一个组，就返回失败，用于判断冗余的边；除此外还可以在并查集中记录组的个数，union一次就减一，还可以加一个connect方法用于判断两个节点是否在同一个组。

拓扑排序：1203，题没看懂，太难了

##12.其他
很多的数组问题可以通过多次翻转数组解决，想不到方法时不妨试试

数组与字符串操作--Z字型变换（6），使用一维数组+StringBuffer代替二维数组更好。
数组旋转（48）--可以转为数组翻转来做，先水平翻转，然后对角线翻转。
多米诺骨牌（1128）--很巧妙，将二元组转化为数字，然后在记录次数，每次出现重复元素就加上之前出现的次数，不用使用排列组合，避免了两次循环或者哈希表的使用。
724数组加法，较简单

数字操作--整数翻转（7,9），整数翻转每个数字的操作：每次将新数字乘10，
然后取10余数，加到新数字中，最后老数字除10。（989）数组加法

找规律：31：找到数组的下一个排列，有规律[i+1,n]必为下降序列，所以找后面数组的
最大值可以从后往前找，第一个就是需要交换的数字，而后续的排序也可以变为直接翻转数组

数学推导：134，加油站问题

罗马数字（12,13）--表驱动法，建两个罗马数字对应的数组，一个存十进制，一个存罗马数字，然后从大到小贪心，得到最终答案，避免平凡的if-else，和那个成绩和等级对应的表驱动有点像，可以多使用（对于多个if-else）

***接雨水问题（42,84,85）---单调栈的使用，很经典。构建单调栈，然后每次有元素出栈时计算面积，其中左边栈顶元素（前一个元素已经出栈的新的栈顶元素）是右边是i（for循环遍历的元素），得到的最大值就是结果。
因为有对于每一个元素而言，其左右分别小于自己的第一个元素为边界构建的矩阵的面积中的最大值就是结果。
因为对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积🌶️ ～

数学公式（1-8）：快速幂算法+余数分解公式，见下方

棋盘问题（1-23）：https://wenku.baidu.com/view/e331f06c336c1eb91a375d75.html，分治法，将大棋盘的分为四个小棋盘，在没有棋子的三个棋盘中分别设置一个点，以此类推，就可以把大问题转化为小问题。

数组移动（189）--环形替换，或者翻转数组
##13.数据结构/算法
单调栈--单调栈就是单调递增/减的栈，然后把不符合要求的循环剔除到符合为止

优先队列，注意默认的是最小堆（取出的都是最小的），初始化的时候要指定大小，加comparator也不例外。
里面的排序是每加入一次重新排序，且不会对原来已经加入的元素进行检查，所以不支持动态修改。

双端队列，deque，可以和单调栈配合使用（升级版单调栈）。

快速幂算法：每次循环将指数/2，判断是否余1，如果有，就将底数平方，累积直到结束，其本质就是把乘方转化为了2进制指数的乘积（也就是把指数转化为二进制求和）也就是a^n = a * a^2 * a^4...

分解余数算法： (A*B)%C = (A%C * B%C)%C，可以将这个和上面的快速幂配合，将底数平方那一步替换为余数的求和公式，从而得到指数的余数。也就是a^n % c= (a * a^2 * a^4...)%c = (a%c * a^2%c ...)%c，求每一项的a^n%c累乘即可。

并查集：可以参考No547，将节点构造成一棵棵的树，对于有相同节点的树进行合并，然后进行路径压缩，将所有子节点直接连接到根节点中，最后可以针对每个集合进行方便的查询。
通过find方法（递归寻找父节点），找到父亲节点的同时压缩路径，union方法合并两棵树（基于find，将一个节点的父节点赋给另一个节点）。parent数组存储每个节点对应的父亲节点，初始化时每个节点的父亲节点都是自己。
注意并查集的中可以在unit方法中添加如果两个节点已经是同一个组，就返回失败，用于判断冗余的边；除此外还可以在并查集中记录组的个数，union一次就减一，还可以加一个connect方法用于判断两个节点是否在同一个组。

最小生成树算法：用于计算吧每个节点连通起来的最短路径和。Prim算法：从任意节点开始每次选中最短的路径，知道全部节点都选中，注意访问后的数组要标记；
Kruskal算法：列出所有的边，每次选中最短的边，然后检查是否成环，这里可以借助并查集实现，每次把选中的点加入并查集，然后合并时判断两个点是否有相同的父节点。

邻接表：https://blog.csdn.net/jnu_simba/article/details/8866844。对邻接矩阵的拓展，用一维的数组存储每个点，然后每个点后接链表存储与之相连的点，并可以在链表的节点中存储边权值的大小

单源最短路径算法：dfs和bfs都可以，但是可能复杂度过高。Dijkstra算法：https://blog.csdn.net/lbperfect123/article/details/84281300，构造dis数组，记录初始点到每个点的最短距离，然后每次寻找最近的点，同时更新dis数组得到最终结果，更新方法是当前节点的dis值+当前节点的目标节点的值。